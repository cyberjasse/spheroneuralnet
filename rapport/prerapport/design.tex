\section{Design du vecteur d'entrée}
\subsection{Données utiles}
Avant de choisir le réseau de neurones à utiliser, il est important d'identifier ce que nous souhaitons obtenir en sortie et les informations que nous pouvons fournir en entrée en omettant les données inutiles.
Si le vecteur d'entrée est de dimension très grande, alors un réseau \rbf devra avoir un trop grand nombre de neurones cachés\cite{Gauthier}.
Si nous supposons que la sortie produite peut dépendre non seulement de l'input actuel mais aussi des entrées précédentes, alors un réseau récurrent devra être utilisé.

La Sphero peut nous fournir:\cite{SDKofficiels}
\begin{itemize}
 \item Sa position grâce à un odomètre (cm),
 \item Son vecteur vitesse (mm/s),
 \item Son vecteur d'accélération grâce à un accéleromètre (mG),
 \item Son orientation (-179$\rightarrow$180 degrés),
 \item Son niveau de charge (Label \enum{Chargement}, \enum{OK}, \enum{Bas}, \enum{Critique}),
 \item État des LEDs, évènement de collision, voltage de la batterie, nombre de charges, version ...
\end{itemize}

Parmis ces données, nous n'avons pas besoin de l'état des LEDs, version et nombre de charges car ils n'influencent pas la conduite de la Shero.
Dans ce projet, nous ne prenons pas en compte les éventuels collisions.

Le niveau de charge pourrait influencer la conduite.
Il se pourrait que la puissance maximale des moteurs diminuent lorsque la charge est trop faible.
Pour ne pas devoir effectuer un entrainement pour chaque niveau de charge différent, on entrainera la Sphero que pour les cas où le niveau de charge est à \enum{OK} et on supposera donc que la conduite sera effectuée qu'avec ce niveau de charge.

Pour l'accélération, les commandes à appliquer à l'instant $t$ ne dépendent pas de l'accélération à l'instant $t$ juste avant l'application des commandes.
Mais par contre, cette donnée peut être utile pour anticiper la vitesse de la Sphero au moment où elle reçoit les commandes car du à la latence d'envoi de paquet, la vitesse à l'instant $t$ n'est plus la même que celle communiquée.
Si cette donnée impacte peu dans les résultats obtenus, alors nous pourrions décider de nous passer de ce paramètre.
Ajouter cette dimension dans le vecteur d'entrée demandera un plus grand nombre d'exemples pour la phases d'apprentissage car il faut balayer toutes les configurations possibles de vecteur d'entrée.

\newcommand{\inchist}[1]{\includegraphics[width=12cm]{../figures/hist#1.jpeg}}
\subsection{Choix du design}
 %TODO montrer les design repris chez gauthier
Pour une meilleure précision, on ajoute un vecteur vitesse à atteindre sur le point de destination.
On aligne l'axe des abscisses avec l'axe de l'orientation du moteur afin de reduire le domaine d'entrée et donc le nombre d'exemples à créer pour l'apprentissage.
Le vecteur d'entrée contiendra donc le vecteur vitesse, la position relative à atteindre dans $T$ secondes où $T$ sera la période à laquelle on échantillonera les données des capteurs.
Nous avons donc un vecteur d'entrée à 6 dimensions (vitesse actuelle en x et y, position relative cible en x et y, vitesse cible en x et y).
Le vecteur de sortie sera la puissance à donner pour chaque moteur.

Estimons la valeur optimale que nous pouvons donner à $T$.
Une commande de streaming de donnée peut être envoyée à la Sphero.
Grâce à cette commande, nous pouvons demander à la Sphero d'envoyer uniquement les données qui nous interessent à une fréquence donnée.
Trois paramètres de cette commande peuvent influencer les performances d'échantillonage:
\begin{enumerate}
 \item Un diviseur (entier) de la fréquence maximale d'échantillonage.
 \item Le nombre d'échantillonage à garder en mémoire avant envoi.
 \item Le nombre de capteur à échantilloner.
\end{enumerate}
Un échantillonage consiste à obtenir seulement les données qui nous intéressent à un instant précis.
La fréquence maximale d'échantillonage, un échantillon à la fois, est de 400Hz.\cite{SDKofficiels}
La vitesse maximale de la Sphero est de 4,5 miles par heure.\cite{product} Ce qui fait environ 2 mètres par seconde.
\begin{figure}
 \centering
 \inchist{20}
 \inchist{60}
 \inchist{80}
 \inchist{100}
 \inchist{200}
 \caption{Histogrammes de temps de réception de packet streamé}
 \label{histogrammes}
\end{figure}

À la Figure \ref{histogrammes} sont repris les histogrammes de temps de réceptions de paquets pour différentes fréquence d'échantillonage.
En plus du streaming, pour chaque paquet reçu, un paquet est envoyé à la Sphero pour changer les leds.
Cela nous permet d'obtenir des résultats qui se rapprocheront de ce que nous obtiendrons si nous envoyons de nouvelles commande chaque pour chaque période $T$.
On observe tout d'abord que les temps de réception ont l'air de suivre une cadence de 1ms.
Cela peut s'expliquer par le fait que la Sphero 2.0 a une granularité de 1ms pour l'éxecution de macro.\cite{product}

Voici les moyennes et écart-types estimées temps de récéptions de packet:\\ %FIXME pas gaussien FIXME inclure config du PC FIXME pas encore parler des donnees collectees

\begin{center}
\begin{tabular}{|l|r|r|}
 \hline
 Fréquence & Moyenne estimée & écart-type estimé\\
 de streaming (Hz) & (microseconde) & (microseconde)\\
 \hline
 20 & 52814 & 16256\\
 60 & 15682 & 6143\\
 80 & 13201 & 6639\\
 100 & 10681 & 6567\\
 200 & 8070 & 2632\\
 \hline
\end{tabular}
\end{center}
